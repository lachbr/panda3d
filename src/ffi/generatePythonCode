#!/usr/local/bin/python


import getopt
import sys
import os
import glob
from direct.ffi import FFIConstants

# Define a help string for the user
helpString ="""
generatePythonCode [opts] -i libtool libcode1 libcode2 ...

Generates Python code for the C++ libraries listed.

Example:
Linux:
  ppython -d generatePythonCode -v -d $DIRECT/lib/py -e $DIRECT/src/extensions -i libdtoolconfig libpandaexpress libpanda libpandaphysics libdirect libtoontown 

Windows debug:
  ppython -d generatePythonCode -v -d `cygpath -w $DIRECT/lib/py` -e `cygpath -w $DIRECT/src/extensions` -i libdtoolconfig libpandaexpress libpanda libpandaphysics libdirect libtoontown 

Windows release:
  ppython generatePythonCode -v -d `cygpath -w $DIRECT/lib/py` -e `cygpath -w $DIRECT/src/extensions` -i libdtoolconfig libpandaexpress libpanda libpandaphysics libdirect libtoontown 

Windows publish (no assertions, no comments, no docstrings):
  ppython -OO generatePythonCode -O -v -d `cygpath -w $DIRECT/lib/py` -e `cygpath -w $DIRECT/src/extensions` -i libdtoolconfig libpandaexpress libpanda libpandaphysics libdirect libtoontown 


Options:
  -h          print this message
  -v          verbose
  -d dir      directory to write output code       
  -e dir      directory to pull extension code from       
  -i lib      interrogate library
  -O          no C++ comments or assertion statements
  -n          Don't use squeezeTool to squeeze the result into one .pyz file
"""

# Initialize variables
outputDir = ''
extensionsDir = ''
interrogateLib = ''
codeLibs = []
doSqueeze = True
    

# Extract the args the user passed in
try:
    opts, pargs = getopt.getopt(sys.argv[1:], 'hvOd:e:i:n')
except Exception, e:
    # User passed in a bad option, print the error and the help, then exit
    print e
    print helpString
    sys.exit()

if len(opts)==0:
    print helpString
    sys.exit()


# Store the option values into our variables
for opt in opts:
    flag, value = opt
    if (flag == '-h'):
        print helpString
        sys.exit()
    elif (flag == '-v'):
        FFIConstants.notify.setInfo(1)
    elif (flag == '-d'):
        outputDir = value
    elif (flag == '-e'):
        extensionsDir = value
    elif (flag == '-i'):
        interrogateLib = value
    elif (flag == '-O'):
        FFIConstants.wantComments = 0
        FFIConstants.wantTypeChecking = 0
    elif (flag == '-n'):
        doSqueeze = False
    else:
        FFIConstants.notify.error('illegal option: ' + flag)

# Store the program arguments into the codeLibs
codeLibs = pargs

# Now do some error checking and verbose output
if (not interrogateLib):
    FFIConstants.notify.error('You must specify an interrogate library (-i lib)')
else:
    FFIConstants.notify.info('Setting interrogate library to: ' + interrogateLib)
    FFIConstants.InterrogateModuleName = interrogateLib

if (not outputDir):
    FFIConstants.notify.info('Setting output directory to current directory')
    outputDir = '.'
elif (not os.path.exists(outputDir)):
    FFIConstants.notify.info('Directory does not exist, creating: ' + outputDir)
    os.mkdir(outputDir)
    FFIConstants.notify.info('Setting output directory to: ' + outputDir)
else:
    FFIConstants.notify.info('Setting output directory to: ' + outputDir)


if (not extensionsDir):
    FFIConstants.notify.info('Setting extensions directory to current directory')
    extensionsDir = '.'
elif (not os.path.exists(extensionsDir)):
    FFIConstants.notify.error('Directory does not exists: ' + extensionsDir)
else:
    FFIConstants.notify.info('Setting extensions directory to: ' + extensionsDir)


if (not codeLibs):
    FFIConstants.notify.error('You must specify one or more libraries to generate code from')
else:
    FFIConstants.notify.info('Generating code for: ' + `codeLibs`)
    FFIConstants.CodeModuleNameList = codeLibs

# Ok, now we can start generating code
from direct.ffi import FFIInterrogateDatabase
db = FFIInterrogateDatabase.FFIInterrogateDatabase()
db.generateCode(outputDir, extensionsDir)


# Remove any leftover junk files in outputDir from a previous run.
print "outputDir = %s, doSqueeze = %s" % (outputDir, doSqueeze)
for file in glob.glob(os.path.join(outputDir, 'PandaModules.py*')):
    print "removing junk %s" % (file)
    os.remove(file)

if doSqueeze:
    # Invoke the squeezer.
    files = glob.glob(os.path.join(outputDir, '*.py'))
    init = os.path.join(outputDir, '__init__.py')
    try:
        files.remove(init)
    except:
        pass

    print "Squeezing %s files." % (len(files))
    
    from direct.showbase import pandaSqueezeTool
    pandaSqueezeTool.squeeze("PandaModules", "PandaModulesUnsqueezed",
                             files, outputDir)

    # Remove the squeezed source files.
    for file in files:
        os.remove(file)

else:
    print "Not squeezing."
    os.rename(os.path.join(outputDir, 'PandaModulesUnsqueezed.py'),
              os.path.join(outputDir, 'PandaModules.py'))
    

    
