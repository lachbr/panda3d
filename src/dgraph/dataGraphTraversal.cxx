// Filename: dataGraphTraversal.cxx
// Created by:  drose (26Jan99)
// 
////////////////////////////////////////////////////////////////////

#include "dataGraphTraversal.h"
#include "dataNode.h"
#include "dataRelation.h"
#include "intDataTransition.h"
#include "intDataAttribute.h"
#include "config_dgraph.h"
#include "describe_data_verbose.h"

#include <renderRelation.h>
#include <dftraverser.h>
#include <node.h>
#include <typeHandle.h>


// Here's the static member of DataGraphTraversal.
TypeHandle DataGraphTraversal::_spam_flag_type;


  
////////////////////////////////////////////////////////////////////
//     Function: DataGraphTraversal::init_spam_flag
//       Access: Public, Static
//  Description: This function is called during static
//               initialization and registers a convenient type handle
//               for the spam flag.
////////////////////////////////////////////////////////////////////
void DataGraphTraversal::
init_spam_flag() {
  // We shouldn't try to call this function more than once.  This
  // function is only to be called during static initialization.
  nassertv(_spam_flag_type == TypeHandle::none());
  IntDataTransition::init_type();
  register_type(_spam_flag_type, "SpamFlagTransition", 
		IntDataTransition::get_class_type());
}
  
////////////////////////////////////////////////////////////////////
//     Function: DataGraphVisitor::reached_node
//       Access: Public
//  Description: 
////////////////////////////////////////////////////////////////////
bool DataGraphVisitor::
reached_node(Node *node, AllAttributesWrapper &state, NullLevelState &) {
  // Is the spam flag set?
  bool has_spam_flag = 
    state.has_attribute(DataGraphTraversal::_spam_flag_type);

  if (has_spam_flag && dgraph_cat.is_info()) {
    dgraph_cat.info() << "Sending into " << *node << " {\n";
    describe_data_verbose(dgraph_cat.info(false), state.get_attributes(), 2);
    dgraph_cat.info(false) << "}\n";
  }

  if (node->is_of_type(DataNode::get_class_type())) {
    DataNode *dnode = DCAST(DataNode, node);

    // Now let the data node process the data itself.
    dnode->transmit_data(state.get_attributes());

    if (dnode->get_spam_mode() && !has_spam_flag) {
      // If the node we pass through has the spam flag set, then we'll
      // set it on our current state, and insist that it gets through
      // to all our children.
      state.set_attribute(DataGraphTraversal::_spam_flag_type, 
			  new IntDataAttribute);
      has_spam_flag = true;
    }
  }

  if (has_spam_flag && !node->_children.empty() && 
      dgraph_cat.is_info()) {
    dgraph_cat.info() << "Receiving from " << *node << " {\n";
    describe_data_verbose(dgraph_cat.info(false), state.get_attributes(), 2);
    dgraph_cat.info(false) << "}\n";
  }
  return true;
}

  
////////////////////////////////////////////////////////////////////
//     Function: traverse_data_graph
//  Description: Initiates a traversal of the data graph given the
//               indicated root node, with no initial data.  Data
//               generated by the nodes encountered will be propagated
//               downwards.
////////////////////////////////////////////////////////////////////
void traverse_data_graph(Node *root) {
  DataGraphVisitor dgv;
  df_traverse(root, dgv, AllAttributesWrapper(), 
	      NullLevelState(), RenderRelation::get_class_type());

  df_traverse(root, dgv, AllAttributesWrapper(), 
	      NullLevelState(), DataRelation::get_class_type());
}
