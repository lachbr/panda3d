// Filename: xParser.yxx
// Created by:  drose (03Oct04)
// 
////////////////////////////////////////////////////////////////////

%{
#include "xLexerDefs.h"
#include "xParserDefs.h"
#include "xFile.h"
#include "xFileTemplate.h"
#include "xFileDataDef.h"
#include "xFileArrayDef.h"
#include "xFileDataObjectTemplate.h"
#include "pointerTo.h"
#include "dcast.h"

// Because our token type contains objects of type string, which
// require correct copy construction (and not simply memcpying), we
// cannot use bison's built-in auto-stack-grow feature.  As an easy
// solution, we ensure here that we have enough yacc stack to start
// with, and that it doesn't ever try to grow.
#define YYINITDEPTH 1000
#define YYMAXDEPTH 1000

static XFile *x_file = (XFile *)NULL;
static XFileNode *current_node = (XFileNode *)NULL;
static PT(XFileDataDef) current_data_def = (XFileDataDef *)NULL;

////////////////////////////////////////////////////////////////////
// Defining the interface to the parser.
////////////////////////////////////////////////////////////////////

void
x_init_parser(istream &in, const string &filename, XFile &file) {
  x_file = &file;
  current_node = &file;
  x_init_lexer(in, filename);
}

void
x_cleanup_parser() {
  x_file = (XFile *)NULL;
  current_node = (XFileNode *)NULL;
}

%}

%token <u.s_int> INTEGER
%token <u.real> REAL
%token <str> STRING IDENTIFIER
%token <guid> WINDOWS_GUID

%token KW_ARRAY 
%token KW_BINARY
%token KW_BYTE
%token KW_CHAR
%token KW_CSTRING
%token KW_DOUBLE
%token KW_DWORD
%token KW_FLOAT
%token KW_STRING
%token KW_TEMPLATE
%token KW_UCHAR
%token KW_UNICODE
%token KW_WORD

%type <u.node> xtemplate
%type <u.node> data_object
%type <str> optional_identifier

%%

xfile:
        empty
        | xfile xtemplate
        | xfile data_object
        ;

xtemplate:
	KW_TEMPLATE IDENTIFIER '{' WINDOWS_GUID
{
  $$ = current_node;
  XFileTemplate *templ = new XFileTemplate($2, $4);
  current_node->add_child(templ);
  current_node = templ;
}
	template_members template_restrictions '}'
{
  $$ = current_node;
  current_node = $<u.node>5;
}
	;

template_members:
	empty
	| template_members template_member ';'
	;

template_member:
        data_def
        | KW_ARRAY data_def array_dimensions
	;

data_def:
        KW_WORD optional_identifier
{
  current_data_def = new XFileDataDef(XFileDataDef::T_word, $2);
  current_node->add_child(current_data_def);
}
	| KW_DWORD optional_identifier
{
  current_data_def = new XFileDataDef(XFileDataDef::T_dword, $2);
  current_node->add_child(current_data_def);
}
	| KW_FLOAT optional_identifier
{
  current_data_def = new XFileDataDef(XFileDataDef::T_float, $2);
  current_node->add_child(current_data_def);
}
	| KW_DOUBLE optional_identifier
{
  current_data_def = new XFileDataDef(XFileDataDef::T_double, $2);
  current_node->add_child(current_data_def);
}
	| KW_CHAR optional_identifier
{
  current_data_def = new XFileDataDef(XFileDataDef::T_char, $2);
  current_node->add_child(current_data_def);
}
	| KW_UCHAR optional_identifier
{
  current_data_def = new XFileDataDef(XFileDataDef::T_uchar, $2);
  current_node->add_child(current_data_def);
}
	| KW_BYTE optional_identifier
{
  current_data_def = new XFileDataDef(XFileDataDef::T_byte, $2);
  current_node->add_child(current_data_def);
}
	| KW_STRING optional_identifier
{
  current_data_def = new XFileDataDef(XFileDataDef::T_string, $2);
  current_node->add_child(current_data_def);
}
	| KW_CSTRING optional_identifier
{
  current_data_def = new XFileDataDef(XFileDataDef::T_cstring, $2);
  current_node->add_child(current_data_def);
}
	| KW_UNICODE optional_identifier
{
  current_data_def = new XFileDataDef(XFileDataDef::T_unicode, $2);
  current_node->add_child(current_data_def);
}
	| IDENTIFIER optional_identifier
{
  XFileTemplate *xtemplate = x_file->find_template($1);
  if (xtemplate == (XFileTemplate *)NULL) {
    yyerror("Unknown template: " + $1);
  } else {
    current_data_def = new XFileDataDef(XFileDataDef::T_template, $2, xtemplate);
    current_node->add_child(current_data_def);
  }
}
	;

array_dimensions:
	array_level
	| array_dimensions array_level
	;

array_level:
	'[' INTEGER ']'
{
  current_data_def->add_array_def(XFileArrayDef($2));
}
	| '[' IDENTIFIER ']'
{
  XFileNode *data_def = current_node->find_child($2);
  if (data_def == (XFileNode *)NULL) {
    yyerror("Unknown identifier: " + $2);
  } else {
    current_data_def->add_array_def(XFileArrayDef(DCAST(XFileDataDef, data_def)));
  }
}
	;

template_restrictions:
	empty
	| '[' '.' '.' '.' ']'
{
  DCAST(XFileTemplate, current_node)->set_open(true);
}
        | '[' template_restriction_list ']'
	;

template_restriction_list:
        template_restriction_element
{
}
	| template_restriction_list ',' template_restriction_element
{
}
	;

template_restriction_element:
	IDENTIFIER
{
  XFileTemplate *xtemplate = x_file->find_template($1);
  if (xtemplate == (XFileTemplate *)NULL) {
    yyerror("Unknown template: " + $1);
  } else {
    DCAST(XFileTemplate, current_node)->add_restriction(xtemplate);
  }
}
	| IDENTIFIER WINDOWS_GUID
{
  XFileTemplate *xtemplate = x_file->find_template($2);
  if (xtemplate == (XFileTemplate *)NULL) {
    yyerror("Unknown template: " + $1);
  } else {
    if (xtemplate->get_name() != $1) {
      xyywarning("GUID identifies template " + xtemplate->get_name() +
                 ", not " + $1);
    }
    DCAST(XFileTemplate, current_node)->add_restriction(xtemplate);
  }
}
	;

data_object:
	IDENTIFIER optional_identifier '{'
{
  XFileTemplate *xtemplate = x_file->find_template($1);
  $$ = current_node;
  
  if (xtemplate == (XFileTemplate *)NULL) {
    yyerror("Unknown template: " + $1);
  } else {
    XFileDataObjectTemplate *templ = 
      new XFileDataObjectTemplate(xtemplate, $2);
    current_node->add_child(templ);
    current_node = templ;
  }
}
	data_object_members '}'
{
  $$ = current_node;
  current_node = $<u.node>4;
}
	;


data_object_members:
	empty
	| data_object_members data_object_member
	;

data_object_member:
	data_object
{
}
        | data_reference
{
}
	| INTEGER
{
}
	| REAL
{
}
        | STRING
{
}
        | ';'
{
}
        | ','
{
}
	;

data_reference:
	'{' IDENTIFIER '}'
	;

optional_identifier:
	empty
{
  $$ = string();
}
	| IDENTIFIER
	;

empty:
        ;

