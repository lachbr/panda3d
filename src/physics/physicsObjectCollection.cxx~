// Filename: physicsObjectCollection.cxx
// Created by:  joswilso (12Jul06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) 2001 - 2004, Disney Enterprises, Inc.  All rights reserved
//
// All use of this software is subject to the terms of the Panda 3d
// Software license.  You should have received a copy of this license
// along with this source code; you will also find a current copy of
// the license at http://etc.cmu.edu/panda3d/docs/license/ .
//
// To contact the maintainers of this program write to
// panda3d-general@lists.sourceforge.net .
//
////////////////////////////////////////////////////////////////////

#include "physicsObjectCollection.h"

#include "indent.h"

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
PhysicsObjectCollection::
PhysicsObjectCollection() {
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
PhysicsObjectCollection::
PhysicsObjectCollection(const PhysicsObjectCollection &copy) :
  _physics_objects(copy._physics_objects)
{
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::Copy Assignment Operator
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
void PhysicsObjectCollection::
operator = (const PhysicsObjectCollection &copy) {
  _physics_objects = copy._physics_objects;
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::add_physics_object
//       Access: Published
//  Description: Adds a new PhysicsObject to the collection.
////////////////////////////////////////////////////////////////////
void PhysicsObjectCollection::
add_physics_object(const PhysicsObject &physics_object) {
  // If the pointer to our internal array is shared by any other
  // PhysicsObjectCollections, we have to copy the array now so we won't
  // inadvertently modify any of our brethren PhysicsObjectCollection
  // objects.

  if (_physics_objects.get_ref_count() > 1) {
    PhysicsObjects old_physics_objects = _physics_objects;
    _physics_objects = PhysicsObjects::empty_array(0);
    _physics_objects.v() = old_physics_objects.v();
  }

  _physics_objects.push_back(physics_object);
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::remove_physics_object
//       Access: Published
//  Description: Removes the indicated PhysicsObject from the collection.
//               Returns true if the physics_object was removed, false if it was
//               not a member of the collection.
////////////////////////////////////////////////////////////////////
bool PhysicsObjectCollection::
remove_physics_object(const PhysicsObject &physics_object) {
  int object_index = -1;
  for (int i = 0; object_index == -1 && i < (int)_physics_objects.size(); i++) {
    if (_physics_objects[i] == physics_object) {
      object_index = i;
    }
  }

  if (object_index == -1) {
    // The indicated physics_object was not a member of the collection.
    return false;
  }

  // If the pointer to our internal array is shared by any other
  // PhysicsObjectCollections, we have to copy the array now so we won't
  // inadvertently modify any of our brethren PhysicsObjectCollection
  // objects.

  if (_physics_objects.get_ref_count() > 1) {
    PhysicsObjects old_physics_objects = _physics_objects;
    _physics_objects = PhysicsObjects::empty_array(0);
    _physics_objects.v() = old_physics_objects.v();
  }

  _physics_objects.erase(_physics_objects.begin() + object_index);
  return true;
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::add_physics_objects_from
//       Access: Published
//  Description: Adds all the PhysicsObjects indicated in the other
//               collection to this collection.  The other 
//               physics_objects are simply appended to the end of 
//               the physics_objects in this list;
//               duplicates are not automatically removed.
////////////////////////////////////////////////////////////////////
void PhysicsObjectCollection::
add_paths_from(const PhysicsObjectCollection &other) {
  int other_num_paths = other.get_num_paths();
  for (int i = 0; i < other_num_paths; i++) {
    add_path(other.get_path(i));
  }
}


////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::remove_paths_from
//       Access: Published
//  Description: Removes from this collection all of the PhysicsObjects
//               listed in the other collection.
////////////////////////////////////////////////////////////////////
void PhysicsObjectCollection::
remove_paths_from(const PhysicsObjectCollection &other) {
  PhysicsObjects new_paths;
  int num_paths = get_num_paths();
  for (int i = 0; i < num_paths; i++) {
    PhysicsObject path = get_path(i);
    if (!other.has_path(path)) {
      new_paths.push_back(path);
    }
  }
  _physics_objects = new_paths;
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::remove_duplicate_paths
//       Access: Published
//  Description: Removes any duplicate entries of the same PhysicsObjects
//               on this collection.  If a PhysicsObject appears multiple
//               times, the first appearance is retained; subsequent
//               appearances are removed.
////////////////////////////////////////////////////////////////////
void PhysicsObjectCollection::
remove_duplicate_paths() {
  PhysicsObjects new_paths;

  int num_paths = get_num_paths();
  for (int i = 0; i < num_paths; i++) {
    PhysicsObject path = get_path(i);
    bool duplicated = false;

    for (int j = 0; j < i && !duplicated; j++) {
      duplicated = (path == get_path(j));
    }

    if (!duplicated) {
      new_paths.push_back(path);
    }
  }

  _physics_objects = new_paths;
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::has_path
//       Access: Published
//  Description: Returns true if the indicated PhysicsObject appears in
//               this collection, false otherwise.
////////////////////////////////////////////////////////////////////
bool PhysicsObjectCollection::
has_path(const PhysicsObject &path) const {
  for (int i = 0; i < get_num_paths(); i++) {
    if (path == get_path(i)) {
      return true;
    }
  }
  return false;
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::clear
//       Access: Published
//  Description: Removes all PhysicsObjects from the collection.
////////////////////////////////////////////////////////////////////
void PhysicsObjectCollection::
clear() {
  _physics_objects.clear();
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::is_empty
//       Access: Published
//  Description: Returns true if there are no PhysicsObjects in the
//               collection, false otherwise.
////////////////////////////////////////////////////////////////////
bool PhysicsObjectCollection::
is_empty() const {
  return _physics_objects.empty();
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::get_num_paths
//       Access: Published
//  Description: Returns the number of PhysicsObjects in the collection.
////////////////////////////////////////////////////////////////////
int PhysicsObjectCollection::
get_num_paths() const {
  return _physics_objects.size();
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::get_path
//       Access: Published
//  Description: Returns the nth PhysicsObject in the collection.
////////////////////////////////////////////////////////////////////
PhysicsObject PhysicsObjectCollection::
get_path(int index) const {
  nassertr(index >= 0 && index < (int)_physics_objects.size(), PhysicsObject());

  return _physics_objects[index];
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::operator []
//       Access: Published
//  Description: Returns the nth PhysicsObject in the collection.  This is
//               the same as get_path(), but it may be a more
//               convenient way to access it.
////////////////////////////////////////////////////////////////////
PhysicsObject PhysicsObjectCollection::
operator [] (int index) const {
  nassertr(index >= 0 && index < (int)_physics_objects.size(), PhysicsObject());

  return _physics_objects[index];
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::output
//       Access: Published
//  Description: Writes a brief one-line description of the
//               PhysicsObjectCollection to the indicated output stream.
////////////////////////////////////////////////////////////////////
void PhysicsObjectCollection::
output(ostream &out) const {
  if (get_num_paths() == 1) {
    out << "1 PhysicsObject";
  } else {
    out << get_num_paths() << " PhysicsObjects";
  }
}

////////////////////////////////////////////////////////////////////
//     Function: PhysicsObjectCollection::write
//       Access: Published
//  Description: Writes a complete multi-line description of the
//               PhysicsObjectCollection to the indicated output stream.
////////////////////////////////////////////////////////////////////
void PhysicsObjectCollection::
write(ostream &out, int indent_level) const {
  for (int i = 0; i < get_num_paths(); i++) {
    indent(out, indent_level) << get_path(i) << "\n";
  }
}
